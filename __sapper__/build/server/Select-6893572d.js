'use strict';

var index = require('./index-7460d1f3.js');
require('./index-4169654c.js');

/* node_modules\svelte-select\src\Item.svelte generated by Svelte v3.16.4 */

const css = {
	code: ".item.svelte-1xfc328{cursor:default;height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--itemPadding, 0 20px);text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.groupHeader.svelte-1xfc328{text-transform:var(--groupTitleTextTransform, uppercase)}.groupItem.svelte-1xfc328{padding-left:40px}.item.svelte-1xfc328:active{background:var(--itemActiveBackground, #b9daff)}.item.active.svelte-1xfc328{background:var(--itemIsActiveBG, #007aff);color:var(--itemIsActiveColor, #fff)}.item.first.svelte-1xfc328{border-radius:var(--itemFirstBorderRadius, 4px 4px 0 0)}.item.hover.svelte-1xfc328:not(.active){background:var(--itemHoverBG, #e7f2ff)}",
	map: "{\"version\":3,\"file\":\"Item.svelte\",\"sources\":[\"Item.svelte\"],\"sourcesContent\":[\"<script>\\n  export let isActive = false;\\n  export let isFirst = false;\\n  export let isHover = false;\\n  export let getOptionLabel = undefined;\\n  export let item = undefined;\\n  export let filterText = '';\\n\\n  let itemClasses = '';\\n\\n  $: {\\n    const classes = [];\\n    if (isActive) { classes.push('active'); }\\n    if (isFirst) { classes.push('first'); }\\n    if (isHover) { classes.push('hover'); }\\n    if (item.isGroupHeader) { classes.push('groupHeader'); }\\n    if (item.isGroupItem) { classes.push('groupItem'); }\\n    itemClasses = classes.join(' ');\\n  }\\n</script>\\n\\n<style>\\n  .item {\\n    cursor: default;\\n    height: var(--height, 42px);\\n    line-height: var(--height, 42px);\\n    padding: var(--itemPadding, 0 20px);\\n    text-overflow: ellipsis;\\n    overflow: hidden;\\n    white-space: nowrap;\\n  }\\n\\n  .groupHeader {\\n    text-transform: var(--groupTitleTextTransform, uppercase);\\n  }\\n\\n  .groupItem {\\n    padding-left: 40px;\\n  }\\n\\n  .item:active {\\n    background: var(--itemActiveBackground, #b9daff);\\n  }\\n\\n  .item.active {\\n    background: var(--itemIsActiveBG, #007aff);\\n    color: var(--itemIsActiveColor, #fff);\\n  }\\n\\n  .item.first {\\n    border-radius: var(--itemFirstBorderRadius, 4px 4px 0 0);\\n  }\\n\\n  .item.hover:not(.active) {\\n    background: var(--itemHoverBG, #e7f2ff);\\n  }\\n</style>\\n\\n\\n\\n<div class=\\\"item {itemClasses}\\\">\\n  {@html getOptionLabel(item, filterText)}\\n</div>\\n\"],\"names\":[],\"mappings\":\"AAsBE,KAAK,eAAC,CAAC,AACL,MAAM,CAAE,OAAO,CACf,MAAM,CAAE,IAAI,QAAQ,CAAC,KAAK,CAAC,CAC3B,WAAW,CAAE,IAAI,QAAQ,CAAC,KAAK,CAAC,CAChC,OAAO,CAAE,IAAI,aAAa,CAAC,OAAO,CAAC,CACnC,aAAa,CAAE,QAAQ,CACvB,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,AACrB,CAAC,AAED,YAAY,eAAC,CAAC,AACZ,cAAc,CAAE,IAAI,yBAAyB,CAAC,UAAU,CAAC,AAC3D,CAAC,AAED,UAAU,eAAC,CAAC,AACV,YAAY,CAAE,IAAI,AACpB,CAAC,AAED,oBAAK,OAAO,AAAC,CAAC,AACZ,UAAU,CAAE,IAAI,sBAAsB,CAAC,QAAQ,CAAC,AAClD,CAAC,AAED,KAAK,OAAO,eAAC,CAAC,AACZ,UAAU,CAAE,IAAI,gBAAgB,CAAC,QAAQ,CAAC,CAC1C,KAAK,CAAE,IAAI,mBAAmB,CAAC,KAAK,CAAC,AACvC,CAAC,AAED,KAAK,MAAM,eAAC,CAAC,AACX,aAAa,CAAE,IAAI,uBAAuB,CAAC,YAAY,CAAC,AAC1D,CAAC,AAED,KAAK,qBAAM,KAAK,OAAO,CAAC,AAAC,CAAC,AACxB,UAAU,CAAE,IAAI,aAAa,CAAC,QAAQ,CAAC,AACzC,CAAC\"}"
};

const Item = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	let { isActive = false } = $$props;
	let { isFirst = false } = $$props;
	let { isHover = false } = $$props;
	let { getOptionLabel = undefined } = $$props;
	let { item = undefined } = $$props;
	let { filterText = "" } = $$props;
	let itemClasses = "";
	if ($$props.isActive === void 0 && $$bindings.isActive && isActive !== void 0) $$bindings.isActive(isActive);
	if ($$props.isFirst === void 0 && $$bindings.isFirst && isFirst !== void 0) $$bindings.isFirst(isFirst);
	if ($$props.isHover === void 0 && $$bindings.isHover && isHover !== void 0) $$bindings.isHover(isHover);
	if ($$props.getOptionLabel === void 0 && $$bindings.getOptionLabel && getOptionLabel !== void 0) $$bindings.getOptionLabel(getOptionLabel);
	if ($$props.item === void 0 && $$bindings.item && item !== void 0) $$bindings.item(item);
	if ($$props.filterText === void 0 && $$bindings.filterText && filterText !== void 0) $$bindings.filterText(filterText);
	$$result.css.add(css);

	 {
		{
			const classes = [];

			if (isActive) {
				classes.push("active");
			}

			if (isFirst) {
				classes.push("first");
			}

			if (isHover) {
				classes.push("hover");
			}

			if (item.isGroupHeader) {
				classes.push("groupHeader");
			}

			if (item.isGroupItem) {
				classes.push("groupItem");
			}

			itemClasses = classes.join(" ");
		}
	}

	return `<div class="${"item " + index.escape(itemClasses) + " svelte-1xfc328"}">
  ${getOptionLabel(item, filterText)}
</div>`;
});

/* node_modules\svelte-select\src\VirtualList.svelte generated by Svelte v3.16.4 */

const css$1 = {
	code: "svelte-virtual-list-viewport.svelte-p6ehlv{position:relative;overflow-y:auto;-webkit-overflow-scrolling:touch;display:block}svelte-virtual-list-contents.svelte-p6ehlv,svelte-virtual-list-row.svelte-p6ehlv{display:block}svelte-virtual-list-row.svelte-p6ehlv{overflow:hidden}",
	map: "{\"version\":3,\"file\":\"VirtualList.svelte\",\"sources\":[\"VirtualList.svelte\"],\"sourcesContent\":[\"<script>\\n\\timport { onMount, tick } from 'svelte';\\n\\n\\t// props\\n\\texport let items = undefined;\\n\\texport let height = '100%';\\n\\texport let itemHeight = 40;\\n\\texport let hoverItemIndex = 0;\\n\\n\\t// read-only, but visible to consumers via bind:start\\n\\texport let start = 0;\\n\\texport let end = 0;\\n\\n\\t// local state\\n\\tlet height_map = [];\\n\\tlet rows;\\n\\tlet viewport;\\n\\tlet contents;\\n\\tlet viewport_height = 0;\\n\\tlet visible;\\n\\tlet mounted;\\n\\n\\tlet top = 0;\\n\\tlet bottom = 0;\\n\\tlet average_height;\\n\\n\\t$: visible = items.slice(start, end).map((data, i) => {\\n\\t\\treturn { index: i + start, data };\\n\\t});\\n\\n\\t// whenever `items` changes, invalidate the current heightmap\\n\\t$: if (mounted) refresh(items, viewport_height, itemHeight);\\n\\n\\tasync function refresh(items, viewport_height, itemHeight) {\\n\\t\\tconst { scrollTop } = viewport;\\n\\n\\t\\tawait tick(); // wait until the DOM is up to date\\n\\n\\t\\tlet content_height = top - scrollTop;\\n\\t\\tlet i = start;\\n\\n\\t\\twhile (content_height < viewport_height && i < items.length) {\\n\\t\\t\\tlet row = rows[i - start];\\n\\n\\t\\t\\tif (!row) {\\n\\t\\t\\t\\tend = i + 1;\\n\\t\\t\\t\\tawait tick(); // render the newly visible row\\n\\t\\t\\t\\trow = rows[i - start];\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst row_height = height_map[i] = itemHeight || row.offsetHeight;\\n\\t\\t\\tcontent_height += row_height;\\n\\t\\t\\ti += 1;\\n\\t\\t}\\n\\n\\t\\tend = i;\\n\\n\\t\\tconst remaining = items.length - end;\\n\\t\\taverage_height = (top + content_height) / end;\\n\\n\\t\\tbottom = remaining * average_height;\\n\\t\\theight_map.length = items.length;\\n\\n\\t\\tviewport.scrollTop = 0;\\n\\t}\\n\\n\\tasync function handle_scroll() {\\n\\t\\tconst { scrollTop } = viewport;\\n\\n\\t\\tconst old_start = start;\\n\\n\\t\\tfor (let v = 0; v < rows.length; v += 1) {\\n\\t\\t\\theight_map[start + v] = itemHeight || rows[v].offsetHeight;\\n\\t\\t}\\n\\n\\t\\tlet i = 0;\\n\\t\\tlet y = 0;\\n\\n\\t\\twhile (i < items.length) {\\n\\t\\t\\tconst row_height = height_map[i] || average_height;\\n\\t\\t\\tif (y + row_height > scrollTop) {\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\ttop = y;\\n\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\ty += row_height;\\n\\t\\t\\ti += 1;\\n\\t\\t}\\n\\n\\t\\twhile (i < items.length) {\\n\\t\\t\\ty += height_map[i] || average_height;\\n\\t\\t\\ti += 1;\\n\\n\\t\\t\\tif (y > scrollTop + viewport_height) break;\\n\\t\\t}\\n\\n\\t\\tend = i;\\n\\n\\t\\tconst remaining = items.length - end;\\n\\t\\taverage_height = y / end;\\n\\n\\t\\twhile (i < items.length) height_map[i++] = average_height;\\n\\t\\tbottom = remaining * average_height;\\n\\n\\t\\t// prevent jumping if we scrolled up into unknown territory\\n\\t\\tif (start < old_start) {\\n\\t\\t\\tawait tick();\\n\\n\\t\\t\\tlet expected_height = 0;\\n\\t\\t\\tlet actual_height = 0;\\n\\n\\t\\t\\tfor (let i = start; i < old_start; i += 1) {\\n\\t\\t\\t\\tif (rows[i - start]) {\\n\\t\\t\\t\\t\\texpected_height += height_map[i];\\n\\t\\t\\t\\t\\tactual_height += itemHeight || rows[i - start].offsetHeight;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst d = actual_height - expected_height;\\n\\t\\t\\tviewport.scrollTo(0, scrollTop + d);\\n\\t\\t}\\n\\n\\t\\t// TODO if we overestimated the space these\\n\\t\\t// rows would occupy we may need to add some\\n\\t\\t// more. maybe we can just call handle_scroll again?\\n\\t}\\n\\n\\t// trigger initial refresh\\n\\tonMount(() => {\\n\\t\\trows = contents.getElementsByTagName('svelte-virtual-list-row');\\n\\t\\tmounted = true;\\n\\t});\\n</script>\\n\\n<style>\\n\\tsvelte-virtual-list-viewport {\\n\\t\\tposition: relative;\\n\\t\\toverflow-y: auto;\\n\\t\\t-webkit-overflow-scrolling: touch;\\n\\t\\tdisplay: block;\\n\\t}\\n\\n\\tsvelte-virtual-list-contents,\\n\\tsvelte-virtual-list-row {\\n\\t\\tdisplay: block;\\n\\t}\\n\\n\\tsvelte-virtual-list-row {\\n\\t\\toverflow: hidden;\\n\\t}\\n</style>\\n\\n<svelte-virtual-list-viewport bind:this={viewport} bind:offsetHeight={viewport_height} on:scroll={handle_scroll}\\n\\tstyle=\\\"height: {height};\\\">\\n\\t<svelte-virtual-list-contents bind:this={contents} style=\\\"padding-top: {top}px; padding-bottom: {bottom}px;\\\">\\n\\t\\t{#each visible as row (row.index)}\\n\\t\\t\\t<svelte-virtual-list-row>\\n\\t\\t\\t\\t<slot item={row.data} i={row.index} {hoverItemIndex}>Missing template</slot>\\n\\t\\t\\t</svelte-virtual-list-row>\\n\\t\\t{/each}\\n\\t</svelte-virtual-list-contents>\\n</svelte-virtual-list-viewport>\"],\"names\":[],\"mappings\":\"AAyIC,4BAA4B,cAAC,CAAC,AAC7B,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,IAAI,CAChB,0BAA0B,CAAE,KAAK,CACjC,OAAO,CAAE,KAAK,AACf,CAAC,AAED,0CAA4B,CAC5B,uBAAuB,cAAC,CAAC,AACxB,OAAO,CAAE,KAAK,AACf,CAAC,AAED,uBAAuB,cAAC,CAAC,AACxB,QAAQ,CAAE,MAAM,AACjB,CAAC\"}"
};

const VirtualList = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	let { items = undefined } = $$props;
	let { height = "100%" } = $$props;
	let { itemHeight = 40 } = $$props;
	let { hoverItemIndex = 0 } = $$props;
	let { start = 0 } = $$props;
	let { end = 0 } = $$props;
	let height_map = [];
	let rows;
	let viewport;
	let contents;
	let viewport_height = 0;
	let visible;
	let mounted;
	let top = 0;
	let bottom = 0;
	let average_height;

	async function refresh(items, viewport_height, itemHeight) {
		const { scrollTop } = viewport;
		await index.tick();
		let content_height = top - scrollTop;
		let i = start;

		while (content_height < viewport_height && i < items.length) {
			let row = rows[i - start];

			if (!row) {
				end = i + 1;
				await index.tick();
				row = rows[i - start];
			}

			const row_height = height_map[i] = itemHeight || row.offsetHeight;
			content_height += row_height;
			i += 1;
		}

		end = i;
		const remaining = items.length - end;
		average_height = (top + content_height) / end;
		bottom = remaining * average_height;
		height_map.length = items.length;
		viewport.scrollTop = 0;
	}

	index.onMount(() => {
		rows = contents.getElementsByTagName("svelte-virtual-list-row");
		mounted = true;
	});

	if ($$props.items === void 0 && $$bindings.items && items !== void 0) $$bindings.items(items);
	if ($$props.height === void 0 && $$bindings.height && height !== void 0) $$bindings.height(height);
	if ($$props.itemHeight === void 0 && $$bindings.itemHeight && itemHeight !== void 0) $$bindings.itemHeight(itemHeight);
	if ($$props.hoverItemIndex === void 0 && $$bindings.hoverItemIndex && hoverItemIndex !== void 0) $$bindings.hoverItemIndex(hoverItemIndex);
	if ($$props.start === void 0 && $$bindings.start && start !== void 0) $$bindings.start(start);
	if ($$props.end === void 0 && $$bindings.end && end !== void 0) $$bindings.end(end);
	$$result.css.add(css$1);

	visible = items.slice(start, end).map((data, i) => {
		return { index: i + start, data };
	});

	 {
		if (mounted) refresh(items, viewport_height, itemHeight);
	}

	return `<svelte-virtual-list-viewport style="${"height: " + index.escape(height) + ";"}" class="${"svelte-p6ehlv"}"${index.add_attribute("this", viewport, 1)}>
	<svelte-virtual-list-contents style="${"padding-top: " + index.escape(top) + "px; padding-bottom: " + index.escape(bottom) + "px;"}" class="${"svelte-p6ehlv"}"${index.add_attribute("this", contents, 1)}>
		${index.each(visible, row => `<svelte-virtual-list-row class="${"svelte-p6ehlv"}">
				${$$slots.default
	? $$slots.default({
			item: row.data,
			i: row.index,
			hoverItemIndex
		})
	: `Missing template`}
			</svelte-virtual-list-row>`)}
	</svelte-virtual-list-contents>
</svelte-virtual-list-viewport>`;
});

/* node_modules\svelte-select\src\List.svelte generated by Svelte v3.16.4 */

const css$2 = {
	code: ".listContainer.svelte-bqv8jo{box-shadow:var(--listShadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));border-radius:var(--listBorderRadius, 4px);max-height:var(--listMaxHeight, 250px);overflow-y:auto;background:var(--listBackground, #fff)}.virtualList.svelte-bqv8jo{height:var(--virtualListHeight, 200px)}.listGroupTitle.svelte-bqv8jo{color:var(--groupTitleColor, #8f8f8f);cursor:default;font-size:var(--groupTitleFontSize, 12px);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--groupTitlePadding, 0 20px);text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap;text-transform:var(--groupTitleTextTransform, uppercase)}.empty.svelte-bqv8jo{text-align:var(--listEmptyTextAlign, center);padding:var(--listEmptyPadding, 20px 0);color:var(--listEmptyColor, #78848F)}",
	map: "{\"version\":3,\"file\":\"List.svelte\",\"sources\":[\"List.svelte\"],\"sourcesContent\":[\"<script>\\n  import { beforeUpdate, createEventDispatcher, onDestroy, onMount, tick } from 'svelte';\\n\\n  const dispatch = createEventDispatcher();\\n\\n  export let container = undefined;\\n\\n  import ItemComponent from './Item.svelte';\\n  import VirtualList from './VirtualList.svelte';\\n\\n  export let Item = ItemComponent;\\n  export let isVirtualList = false;\\n  export let items = [];\\n  export let getOptionLabel = (option, filterText) => {\\n    if (option) return option.isCreator ? `Create \\\\\\\"${filterText}\\\\\\\"` : option.label;\\n  };\\n  export let getGroupHeaderLabel = (option) => { return option.label };\\n  export let itemHeight = 40;\\n  export let hoverItemIndex = 0;\\n  export let selectedValue = undefined;\\n  export let optionIdentifier = 'value';\\n  export let hideEmptyState = false;\\n  export let noOptionsMessage = 'No options';\\n  export let isMulti = false;\\n  export let activeItemIndex = 0;\\n  export let filterText = '';\\n\\n  let isScrollingTimer = 0;\\n  let isScrolling = false;\\n  let prev_items;\\n  let prev_activeItemIndex;\\n  let prev_selectedValue;\\n\\n  onMount(() => {\\n    if (items.length > 0 && !isMulti && selectedValue) {\\n      const _hoverItemIndex = items.findIndex((item) => item[optionIdentifier] === selectedValue[optionIdentifier]);\\n\\n      if (_hoverItemIndex) {\\n        hoverItemIndex = _hoverItemIndex;\\n      }\\n    }\\n\\n    scrollToActiveItem('active');\\n\\n\\n    container.addEventListener('scroll', () => {\\n      clearTimeout(isScrollingTimer);\\n\\n      isScrollingTimer = setTimeout(() => {\\n        isScrolling = false;\\n      }, 100);\\n    }, false);\\n  });\\n\\n  onDestroy(() => {\\n    // clearTimeout(isScrollingTimer);\\n  });\\n\\n  beforeUpdate(() => {\\n\\n    if (items !== prev_items && items.length > 0) {\\n      hoverItemIndex = 0;\\n    }\\n\\n\\n    // if (prev_activeItemIndex && activeItemIndex > -1) {\\n    //   hoverItemIndex = activeItemIndex;\\n\\n    //   scrollToActiveItem('active');\\n    // }\\n    // if (prev_selectedValue && selectedValue) {\\n    //   scrollToActiveItem('active');\\n\\n    //   if (items && !isMulti) {\\n    //     const hoverItemIndex = items.findIndex((item) => item[optionIdentifier] === selectedValue[optionIdentifier]);\\n\\n    //     if (hoverItemIndex) {\\n    //       hoverItemIndex = hoverItemIndex;\\n    //     }\\n    //   }\\n    // }\\n\\n    prev_items = items;\\n    prev_activeItemIndex = activeItemIndex;\\n    prev_selectedValue = selectedValue;\\n  });\\n\\n  function itemClasses(hoverItemIndex, item, itemIndex, items, selectedValue, optionIdentifier, isMulti) {\\n    return `${selectedValue && !isMulti && (selectedValue[optionIdentifier] === item[optionIdentifier]) ? 'active ' : ''}${hoverItemIndex === itemIndex || items.length === 1 ? 'hover' : ''}`;\\n  }\\n\\n  function handleSelect(item) {\\n    if (item.isCreator) return;\\n    dispatch('itemSelected', item);\\n  }\\n\\n  function handleHover(i) {\\n    if (isScrolling) return;\\n    hoverItemIndex = i;\\n  }\\n\\n  function handleClick(args) {\\n    const { item, i, event } = args;\\n    event.stopPropagation();\\n\\n    if (selectedValue && !isMulti && selectedValue[optionIdentifier] === item[optionIdentifier]) return closeList();\\n\\n    if (item.isCreator) {\\n      dispatch('itemCreated', filterText);\\n    } else {\\n      activeItemIndex = i;\\n      hoverItemIndex = i;\\n      handleSelect(item);\\n    }\\n  }\\n\\n  function closeList() {\\n    dispatch('closeList');\\n  }\\n\\n  async function updateHoverItem(increment) {\\n    if (isVirtualList) return;\\n\\n    let isNonSelectableItem = true;\\n\\n    while (isNonSelectableItem) {\\n      if (increment > 0 && hoverItemIndex === (items.length - 1)) {\\n        hoverItemIndex = 0;\\n      }\\n      else if (increment < 0 && hoverItemIndex === 0) {\\n        hoverItemIndex = items.length - 1;\\n      }\\n      else {\\n        hoverItemIndex = hoverItemIndex + increment;\\n      }\\n\\n      isNonSelectableItem = items[hoverItemIndex].isGroupHeader && !items[hoverItemIndex].isSelectable;\\n    }\\n\\n    await tick();\\n\\n    scrollToActiveItem('hover');\\n  }\\n\\n  function handleKeyDown(e) {\\n    switch (e.key) {\\n      case 'ArrowDown':\\n        e.preventDefault();\\n        items.length && updateHoverItem(1);\\n        break;\\n      case 'ArrowUp':\\n        e.preventDefault();\\n        items.length && updateHoverItem(-1);\\n        break;\\n      case 'Enter':\\n        e.preventDefault();\\n        if (items.length === 0) break;\\n        const hoverItem = items[hoverItemIndex];\\n        if (selectedValue && !isMulti && selectedValue[optionIdentifier] === hoverItem[optionIdentifier]) {\\n          closeList();\\n          break;\\n        }\\n\\n        if (hoverItem.isCreator) {\\n          dispatch('itemCreated', filterText);\\n        } else {\\n          activeItemIndex = hoverItemIndex;\\n          handleSelect(items[hoverItemIndex]);\\n        }\\n        break;\\n      case 'Tab':\\n        e.preventDefault();\\n        if (items.length === 0) break;\\n        if (selectedValue && selectedValue[optionIdentifier] === items[hoverItemIndex][optionIdentifier]) return closeList();\\n        activeItemIndex = hoverItemIndex;\\n        handleSelect(items[hoverItemIndex]);\\n        break;\\n    }\\n  }\\n\\n  function scrollToActiveItem(className) {\\n    if (isVirtualList || !container) return;\\n\\n    let offsetBounding;\\n    const focusedElemBounding = container.querySelector(`.listItem .${className}`);\\n\\n    if (focusedElemBounding) {\\n      offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;\\n    }\\n\\n    container.scrollTop -= offsetBounding;\\n  }\\n\\n  function isItemActive(item, selectedValue, optionIdentifier) {\\n    return selectedValue && (selectedValue[optionIdentifier] === item[optionIdentifier]);\\n  };\\n\\n  function isItemFirst(itemIndex) {\\n    return itemIndex === 0;\\n  };\\n\\n  function isItemHover(hoverItemIndex, item, itemIndex, items) {\\n    return hoverItemIndex === itemIndex || items.length === 1;\\n  }\\n\\n</script>\\n\\n<svelte:window on:keydown=\\\"{handleKeyDown}\\\" />\\n\\n{#if isVirtualList}\\n<div class=\\\"listContainer virtualList\\\" bind:this={container}>\\n\\n  <VirtualList {items} {itemHeight} let:item let:i>\\n  \\n    <div on:mouseover=\\\"{() => handleHover(i)}\\\" on:click=\\\"{event => handleClick({item, i, event})}\\\"\\n        class=\\\"listItem\\\">\\n          <svelte:component \\n            this=\\\"{Item}\\\"\\n            {item}\\n            {filterText}\\n            {getOptionLabel}\\n            isFirst=\\\"{isItemFirst(i)}\\\"\\n            isActive=\\\"{isItemActive(item, selectedValue, optionIdentifier)}\\\"\\n            isHover=\\\"{isItemHover(hoverItemIndex, item, i, items)}\\\"\\n          />\\n    </div>\\n  \\n</VirtualList>\\n</div>\\n{/if}\\n\\n{#if !isVirtualList}\\n<div class=\\\"listContainer\\\" bind:this={container}>\\n  {#each items as item, i}\\n    {#if item.isGroupHeader && !item.isSelectable}\\n      <div class=\\\"listGroupTitle\\\">{getGroupHeaderLabel(item)}</div>\\n    { :else }\\n    <div \\n      on:mouseover=\\\"{() => handleHover(i)}\\\" \\n      on:click=\\\"{event => handleClick({item, i, event})}\\\"\\n      class=\\\"listItem\\\"\\n    >\\n      <svelte:component \\n        this=\\\"{Item}\\\"\\n        {item}\\n        {filterText}\\n        {getOptionLabel}\\n        isFirst=\\\"{isItemFirst(i)}\\\"\\n        isActive=\\\"{isItemActive(item, selectedValue, optionIdentifier)}\\\"\\n        isHover=\\\"{isItemHover(hoverItemIndex, item, i, items)}\\\"\\n      />\\n    </div>\\n    {/if}\\n  {:else}\\n    {#if !hideEmptyState}\\n      <div class=\\\"empty\\\">{noOptionsMessage}</div>\\n    {/if}\\n  {/each}\\n</div>\\n{/if}\\n\\n<style>\\n  .listContainer {\\n    box-shadow: var(--listShadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));\\n    border-radius: var(--listBorderRadius, 4px);\\n    max-height: var(--listMaxHeight, 250px);\\n    overflow-y: auto;\\n    background: var(--listBackground, #fff);\\n  }\\n\\n  .virtualList {\\n    height: var(--virtualListHeight, 200px);\\n  }\\n\\n  .listGroupTitle {\\n    color: var(--groupTitleColor, #8f8f8f);\\n    cursor: default;\\n    font-size: var(--groupTitleFontSize, 12px);\\n    height: var(--height, 42px);\\n    line-height: var(--height, 42px);\\n    padding: var(--groupTitlePadding, 0 20px);\\n    text-overflow: ellipsis;\\n    overflow-x: hidden;\\n    white-space: nowrap;\\n    text-transform: var(--groupTitleTextTransform, uppercase);\\n  }\\n\\n  .empty {\\n    text-align: var(--listEmptyTextAlign, center);\\n    padding: var(--listEmptyPadding, 20px 0);\\n    color: var(--listEmptyColor, #78848F);\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AAsQE,cAAc,cAAC,CAAC,AACd,UAAU,CAAE,IAAI,YAAY,CAAC,mCAAmC,CAAC,CACjE,aAAa,CAAE,IAAI,kBAAkB,CAAC,IAAI,CAAC,CAC3C,UAAU,CAAE,IAAI,eAAe,CAAC,MAAM,CAAC,CACvC,UAAU,CAAE,IAAI,CAChB,UAAU,CAAE,IAAI,gBAAgB,CAAC,KAAK,CAAC,AACzC,CAAC,AAED,YAAY,cAAC,CAAC,AACZ,MAAM,CAAE,IAAI,mBAAmB,CAAC,MAAM,CAAC,AACzC,CAAC,AAED,eAAe,cAAC,CAAC,AACf,KAAK,CAAE,IAAI,iBAAiB,CAAC,QAAQ,CAAC,CACtC,MAAM,CAAE,OAAO,CACf,SAAS,CAAE,IAAI,oBAAoB,CAAC,KAAK,CAAC,CAC1C,MAAM,CAAE,IAAI,QAAQ,CAAC,KAAK,CAAC,CAC3B,WAAW,CAAE,IAAI,QAAQ,CAAC,KAAK,CAAC,CAChC,OAAO,CAAE,IAAI,mBAAmB,CAAC,OAAO,CAAC,CACzC,aAAa,CAAE,QAAQ,CACvB,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,MAAM,CACnB,cAAc,CAAE,IAAI,yBAAyB,CAAC,UAAU,CAAC,AAC3D,CAAC,AAED,MAAM,cAAC,CAAC,AACN,UAAU,CAAE,IAAI,oBAAoB,CAAC,OAAO,CAAC,CAC7C,OAAO,CAAE,IAAI,kBAAkB,CAAC,OAAO,CAAC,CACxC,KAAK,CAAE,IAAI,gBAAgB,CAAC,QAAQ,CAAC,AACvC,CAAC\"}"
};

function isItemActive(item, selectedValue, optionIdentifier) {
	return selectedValue && selectedValue[optionIdentifier] === item[optionIdentifier];
}

function isItemFirst(itemIndex) {
	return itemIndex === 0;
}

function isItemHover(hoverItemIndex, item, itemIndex, items) {
	return hoverItemIndex === itemIndex || items.length === 1;
}

const List = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	const dispatch = index.createEventDispatcher();
	let { container = undefined } = $$props;
	let { Item: Item$1 = Item } = $$props;
	let { isVirtualList = false } = $$props;
	let { items = [] } = $$props;

	let { getOptionLabel = (option, filterText) => {
		if (option) return option.isCreator
		? `Create \"${filterText}\"`
		: option.label;
	} } = $$props;

	let { getGroupHeaderLabel = option => {
		return option.label;
	} } = $$props;

	let { itemHeight = 40 } = $$props;
	let { hoverItemIndex = 0 } = $$props;
	let { selectedValue = undefined } = $$props;
	let { optionIdentifier = "value" } = $$props;
	let { hideEmptyState = false } = $$props;
	let { noOptionsMessage = "No options" } = $$props;
	let { isMulti = false } = $$props;
	let { activeItemIndex = 0 } = $$props;
	let { filterText = "" } = $$props;
	let isScrollingTimer = 0;
	let prev_items;

	index.onMount(() => {
		if (items.length > 0 && !isMulti && selectedValue) {
			const _hoverItemIndex = items.findIndex(item => item[optionIdentifier] === selectedValue[optionIdentifier]);

			if (_hoverItemIndex) {
				hoverItemIndex = _hoverItemIndex;
			}
		}

		scrollToActiveItem("active");

		container.addEventListener(
			"scroll",
			() => {
				clearTimeout(isScrollingTimer);

				isScrollingTimer = setTimeout(
					() => {
					},
					100
				);
			},
			false
		);
	});

	index.onDestroy(() => {
		
	});

	index.beforeUpdate(() => {
		if (items !== prev_items && items.length > 0) {
			hoverItemIndex = 0;
		}

		prev_items = items;
	});

	function scrollToActiveItem(className) {
		if (isVirtualList || !container) return;
		let offsetBounding;
		const focusedElemBounding = container.querySelector(`.listItem .${className}`);

		if (focusedElemBounding) {
			offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
		}

		container.scrollTop -= offsetBounding;
	}

	
	
	if ($$props.container === void 0 && $$bindings.container && container !== void 0) $$bindings.container(container);
	if ($$props.Item === void 0 && $$bindings.Item && Item$1 !== void 0) $$bindings.Item(Item$1);
	if ($$props.isVirtualList === void 0 && $$bindings.isVirtualList && isVirtualList !== void 0) $$bindings.isVirtualList(isVirtualList);
	if ($$props.items === void 0 && $$bindings.items && items !== void 0) $$bindings.items(items);
	if ($$props.getOptionLabel === void 0 && $$bindings.getOptionLabel && getOptionLabel !== void 0) $$bindings.getOptionLabel(getOptionLabel);
	if ($$props.getGroupHeaderLabel === void 0 && $$bindings.getGroupHeaderLabel && getGroupHeaderLabel !== void 0) $$bindings.getGroupHeaderLabel(getGroupHeaderLabel);
	if ($$props.itemHeight === void 0 && $$bindings.itemHeight && itemHeight !== void 0) $$bindings.itemHeight(itemHeight);
	if ($$props.hoverItemIndex === void 0 && $$bindings.hoverItemIndex && hoverItemIndex !== void 0) $$bindings.hoverItemIndex(hoverItemIndex);
	if ($$props.selectedValue === void 0 && $$bindings.selectedValue && selectedValue !== void 0) $$bindings.selectedValue(selectedValue);
	if ($$props.optionIdentifier === void 0 && $$bindings.optionIdentifier && optionIdentifier !== void 0) $$bindings.optionIdentifier(optionIdentifier);
	if ($$props.hideEmptyState === void 0 && $$bindings.hideEmptyState && hideEmptyState !== void 0) $$bindings.hideEmptyState(hideEmptyState);
	if ($$props.noOptionsMessage === void 0 && $$bindings.noOptionsMessage && noOptionsMessage !== void 0) $$bindings.noOptionsMessage(noOptionsMessage);
	if ($$props.isMulti === void 0 && $$bindings.isMulti && isMulti !== void 0) $$bindings.isMulti(isMulti);
	if ($$props.activeItemIndex === void 0 && $$bindings.activeItemIndex && activeItemIndex !== void 0) $$bindings.activeItemIndex(activeItemIndex);
	if ($$props.filterText === void 0 && $$bindings.filterText && filterText !== void 0) $$bindings.filterText(filterText);
	$$result.css.add(css$2);

	return `

${isVirtualList
	? `<div class="${"listContainer virtualList svelte-bqv8jo"}"${index.add_attribute("this", container, 1)}>

  ${index.validate_component(VirtualList, "VirtualList").$$render($$result, { items, itemHeight }, {}, {
			default: ({ item, i }) => `
  
    <div class="${"listItem"}">
          ${index.validate_component(Item$1 || index.missing_component, "svelte:component").$$render(
				$$result,
				{
					item,
					filterText,
					getOptionLabel,
					isFirst: isItemFirst(i),
					isActive: isItemActive(item, selectedValue, optionIdentifier),
					isHover: isItemHover(hoverItemIndex, item, i, items)
				},
				{},
				{}
			)}
    </div>
  
`
		})}
</div>`
	: ``}

${!isVirtualList
	? `<div class="${"listContainer svelte-bqv8jo"}"${index.add_attribute("this", container, 1)}>
  ${items.length
		? index.each(items, (item, i) => `${item.isGroupHeader && !item.isSelectable
			? `<div class="${"listGroupTitle svelte-bqv8jo"}">${index.escape(getGroupHeaderLabel(item))}</div>`
			: `<div class="${"listItem"}">
      ${index.validate_component(Item$1 || index.missing_component, "svelte:component").$$render(
					$$result,
					{
						item,
						filterText,
						getOptionLabel,
						isFirst: isItemFirst(i),
						isActive: isItemActive(item, selectedValue, optionIdentifier),
						isHover: isItemHover(hoverItemIndex, item, i, items)
					},
					{},
					{}
				)}
    </div>`}`)
		: `${!hideEmptyState
			? `<div class="${"empty svelte-bqv8jo"}">${index.escape(noOptionsMessage)}</div>`
			: ``}`}
</div>`
	: ``}`;
});

/* node_modules\svelte-select\src\Selection.svelte generated by Svelte v3.16.4 */

const css$3 = {
	code: ".selection.svelte-ch6bh7{text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap}",
	map: "{\"version\":3,\"file\":\"Selection.svelte\",\"sources\":[\"Selection.svelte\"],\"sourcesContent\":[\"<script>\\n  export let getSelectionLabel = undefined;\\n  export let item = undefined;\\n</script>\\n\\n<style>\\n  .selection {\\n    text-overflow: ellipsis;\\n    overflow-x: hidden;\\n    white-space: nowrap;\\n  }\\n</style>\\n\\n<div class=\\\"selection\\\">\\n  {@html getSelectionLabel(item)} \\n</div>\\n\"],\"names\":[],\"mappings\":\"AAME,UAAU,cAAC,CAAC,AACV,aAAa,CAAE,QAAQ,CACvB,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,MAAM,AACrB,CAAC\"}"
};

const Selection = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	let { getSelectionLabel = undefined } = $$props;
	let { item = undefined } = $$props;
	if ($$props.getSelectionLabel === void 0 && $$bindings.getSelectionLabel && getSelectionLabel !== void 0) $$bindings.getSelectionLabel(getSelectionLabel);
	if ($$props.item === void 0 && $$bindings.item && item !== void 0) $$bindings.item(item);
	$$result.css.add(css$3);

	return `<div class="${"selection svelte-ch6bh7"}">
  ${getSelectionLabel(item)} 
</div>`;
});

/* node_modules\svelte-select\src\MultiSelection.svelte generated by Svelte v3.16.4 */

const css$4 = {
	code: ".multiSelectItem.svelte-rtzfov{background:var(--multiItemBG, #EBEDEF);margin:var(--multiItemMargin, 5px 5px 0 0);border-radius:var(--multiItemBorderRadius, 16px);height:var(--multiItemHeight, 32px);line-height:var(--multiItemHeight, 32px);display:flex;cursor:default;padding:var(--multiItemPadding, 0 10px 0 15px)}.multiSelectItem_label.svelte-rtzfov{margin:var(--multiLabelMargin, 0 5px 0 0)}.multiSelectItem.svelte-rtzfov:hover,.multiSelectItem.active.svelte-rtzfov{background-color:var(--multiItemActiveBG, #006FFF);color:var(--multiItemActiveColor, #fff)}.multiSelectItem.disabled.svelte-rtzfov:hover{background:var(--multiItemDisabledHoverBg, #EBEDEF);color:var(--multiItemDisabledHoverColor, #C1C6CC)}.multiSelectItem_clear.svelte-rtzfov{border-radius:var(--multiClearRadius, 50%);background:var(--multiClearBG, #52616F);width:var(--multiClearWidth, 16px);height:var(--multiClearHeight, 16px);position:relative;top:var(--multiClearTop, 8px);text-align:var(--multiClearTextAlign, center);padding:var(--multiClearPadding, 1px)}.multiSelectItem_clear.svelte-rtzfov:hover,.active.svelte-rtzfov .multiSelectItem_clear.svelte-rtzfov{background:var(--multiClearHoverBG, #fff)}.multiSelectItem_clear.svelte-rtzfov:hover svg.svelte-rtzfov,.active.svelte-rtzfov .multiSelectItem_clear svg.svelte-rtzfov{fill:var(--multiClearHoverFill, #006FFF)}.multiSelectItem_clear.svelte-rtzfov svg.svelte-rtzfov{fill:var(--multiClearFill, #EBEDEF);vertical-align:top}",
	map: "{\"version\":3,\"file\":\"MultiSelection.svelte\",\"sources\":[\"MultiSelection.svelte\"],\"sourcesContent\":[\"<script>\\n  import { createEventDispatcher } from 'svelte';\\n\\n  const dispatch = createEventDispatcher();\\n\\n  export let selectedValue = [];\\n  export let activeSelectedValue = undefined;\\n  export let isDisabled = false;\\n  export let getSelectionLabel = undefined;\\n\\n  function handleClear(i, event) {\\n    event.stopPropagation();\\n    dispatch('multiItemClear', {i});\\n  }\\n</script>\\n\\n{#each selectedValue as value, i}\\n<div class=\\\"multiSelectItem {activeSelectedValue === i ? 'active' : ''} {isDisabled ? 'disabled' : ''}\\\">\\n  <div class=\\\"multiSelectItem_label\\\">\\n    {@html getSelectionLabel(value)}\\n  </div>\\n  {#if !isDisabled}\\n  <div class=\\\"multiSelectItem_clear\\\" on:click=\\\"{event => handleClear(i, event)}\\\">\\n    <svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"-2 -2 50 50\\\" focusable=\\\"false\\\" role=\\\"presentation\\\">\\n      <path\\n        d=\\\"M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z\\\"></path>\\n    </svg>\\n  </div>\\n  {/if}\\n</div>\\n{/each}\\n\\n\\n\\n<style>\\n  .multiSelectItem {\\n    background: var(--multiItemBG, #EBEDEF);\\n    margin: var(--multiItemMargin, 5px 5px 0 0);\\n    border-radius: var(--multiItemBorderRadius, 16px);\\n    height: var(--multiItemHeight, 32px);\\n    line-height: var(--multiItemHeight, 32px);\\n    display: flex;\\n    cursor: default;\\n    padding: var(--multiItemPadding, 0 10px 0 15px);\\n  }\\n\\n  .multiSelectItem_label {\\n    margin: var(--multiLabelMargin, 0 5px 0 0);\\n  }\\n\\n  .multiSelectItem:hover,\\n  .multiSelectItem.active {\\n    background-color: var(--multiItemActiveBG, #006FFF);\\n    color: var(--multiItemActiveColor, #fff);\\n  }\\n\\n  .multiSelectItem.disabled:hover {\\n    background: var(--multiItemDisabledHoverBg, #EBEDEF);\\n    color: var(--multiItemDisabledHoverColor, #C1C6CC);\\n  }\\n\\n  .multiSelectItem_clear {\\n    border-radius: var(--multiClearRadius, 50%);\\n    background: var(--multiClearBG, #52616F);\\n    width: var(--multiClearWidth, 16px);\\n    height: var(--multiClearHeight, 16px);\\n    position: relative;\\n    top: var(--multiClearTop, 8px);\\n    text-align: var(--multiClearTextAlign, center);\\n    padding: var(--multiClearPadding, 1px);\\n  }\\n\\n  .multiSelectItem_clear:hover,\\n  .active .multiSelectItem_clear {\\n    background: var(--multiClearHoverBG, #fff);\\n  }\\n\\n  .multiSelectItem_clear:hover svg,\\n  .active .multiSelectItem_clear svg {\\n    fill: var(--multiClearHoverFill, #006FFF);\\n  }\\n\\n  .multiSelectItem_clear svg {\\n    fill: var(--multiClearFill, #EBEDEF);\\n    vertical-align: top;\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"AAmCE,gBAAgB,cAAC,CAAC,AAChB,UAAU,CAAE,IAAI,aAAa,CAAC,QAAQ,CAAC,CACvC,MAAM,CAAE,IAAI,iBAAiB,CAAC,YAAY,CAAC,CAC3C,aAAa,CAAE,IAAI,uBAAuB,CAAC,KAAK,CAAC,CACjD,MAAM,CAAE,IAAI,iBAAiB,CAAC,KAAK,CAAC,CACpC,WAAW,CAAE,IAAI,iBAAiB,CAAC,KAAK,CAAC,CACzC,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,OAAO,CACf,OAAO,CAAE,IAAI,kBAAkB,CAAC,cAAc,CAAC,AACjD,CAAC,AAED,sBAAsB,cAAC,CAAC,AACtB,MAAM,CAAE,IAAI,kBAAkB,CAAC,UAAU,CAAC,AAC5C,CAAC,AAED,8BAAgB,MAAM,CACtB,gBAAgB,OAAO,cAAC,CAAC,AACvB,gBAAgB,CAAE,IAAI,mBAAmB,CAAC,QAAQ,CAAC,CACnD,KAAK,CAAE,IAAI,sBAAsB,CAAC,KAAK,CAAC,AAC1C,CAAC,AAED,gBAAgB,uBAAS,MAAM,AAAC,CAAC,AAC/B,UAAU,CAAE,IAAI,0BAA0B,CAAC,QAAQ,CAAC,CACpD,KAAK,CAAE,IAAI,6BAA6B,CAAC,QAAQ,CAAC,AACpD,CAAC,AAED,sBAAsB,cAAC,CAAC,AACtB,aAAa,CAAE,IAAI,kBAAkB,CAAC,IAAI,CAAC,CAC3C,UAAU,CAAE,IAAI,cAAc,CAAC,QAAQ,CAAC,CACxC,KAAK,CAAE,IAAI,iBAAiB,CAAC,KAAK,CAAC,CACnC,MAAM,CAAE,IAAI,kBAAkB,CAAC,KAAK,CAAC,CACrC,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,eAAe,CAAC,IAAI,CAAC,CAC9B,UAAU,CAAE,IAAI,qBAAqB,CAAC,OAAO,CAAC,CAC9C,OAAO,CAAE,IAAI,mBAAmB,CAAC,IAAI,CAAC,AACxC,CAAC,AAED,oCAAsB,MAAM,CAC5B,qBAAO,CAAC,sBAAsB,cAAC,CAAC,AAC9B,UAAU,CAAE,IAAI,mBAAmB,CAAC,KAAK,CAAC,AAC5C,CAAC,AAED,oCAAsB,MAAM,CAAC,iBAAG,CAChC,qBAAO,CAAC,sBAAsB,CAAC,GAAG,cAAC,CAAC,AAClC,IAAI,CAAE,IAAI,qBAAqB,CAAC,QAAQ,CAAC,AAC3C,CAAC,AAED,oCAAsB,CAAC,GAAG,cAAC,CAAC,AAC1B,IAAI,CAAE,IAAI,gBAAgB,CAAC,QAAQ,CAAC,CACpC,cAAc,CAAE,GAAG,AACrB,CAAC\"}"
};

const MultiSelection = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	const dispatch = index.createEventDispatcher();
	let { selectedValue = [] } = $$props;
	let { activeSelectedValue = undefined } = $$props;
	let { isDisabled = false } = $$props;
	let { getSelectionLabel = undefined } = $$props;

	if ($$props.selectedValue === void 0 && $$bindings.selectedValue && selectedValue !== void 0) $$bindings.selectedValue(selectedValue);
	if ($$props.activeSelectedValue === void 0 && $$bindings.activeSelectedValue && activeSelectedValue !== void 0) $$bindings.activeSelectedValue(activeSelectedValue);
	if ($$props.isDisabled === void 0 && $$bindings.isDisabled && isDisabled !== void 0) $$bindings.isDisabled(isDisabled);
	if ($$props.getSelectionLabel === void 0 && $$bindings.getSelectionLabel && getSelectionLabel !== void 0) $$bindings.getSelectionLabel(getSelectionLabel);
	$$result.css.add(css$4);

	return `${index.each(selectedValue, (value, i) => `<div class="${"multiSelectItem " + index.escape(activeSelectedValue === i ? "active" : "") + " " + index.escape(isDisabled ? "disabled" : "") + " svelte-rtzfov"}">
  <div class="${"multiSelectItem_label svelte-rtzfov"}">
    ${getSelectionLabel(value)}
  </div>
  ${!isDisabled
	? `<div class="${"multiSelectItem_clear svelte-rtzfov"}">
    <svg width="${"100%"}" height="${"100%"}" viewBox="${"-2 -2 50 50"}" focusable="${"false"}" role="${"presentation"}" class="${"svelte-rtzfov"}">
      <path d="${"M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z"}"></path>
    </svg>
  </div>`
	: ``}
</div>`)}`;
});

function isOutOfViewport(elem) {
  const bounding = elem.getBoundingClientRect();
  const out = {};

  out.top = bounding.top < 0;
  out.left = bounding.left < 0;
  out.bottom = bounding.bottom > (window.innerHeight || document.documentElement.clientHeight);
  out.right = bounding.right > (window.innerWidth || document.documentElement.clientWidth);
  out.any = out.top || out.left || out.bottom || out.right;

  return out;
}

function debounce(func, wait, immediate) {
  let timeout;

  return function executedFunction() {
    let context = this;
    let args = arguments;
	    
    let later = function() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    let callNow = immediate && !timeout;
	
    clearTimeout(timeout);

    timeout = setTimeout(later, wait);
	
    if (callNow) func.apply(context, args);
  };
}

/* node_modules\svelte-select\src\Select.svelte generated by Svelte v3.16.4 */

const css$5 = {
	code: ".selectContainer.svelte-e3bo9s{border:var(--border, 1px solid #D8DBDF);border-radius:var(--borderRadius, 3px);height:var(--height, 42px);position:relative;display:flex;padding:var(--padding, 0 16px);background:var(--background, #fff)}.selectContainer.svelte-e3bo9s input.svelte-e3bo9s{cursor:default;border:none;color:var(--inputColor, #3F4F5F);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--padding, 0 16px);width:100%;background:transparent;font-size:var(--inputFontSize, 14px);letter-spacing:var(--inputLetterSpacing, -0.08px);position:absolute;left:0}.selectContainer.svelte-e3bo9s input.svelte-e3bo9s::placeholder{color:var(--placeholderColor, #78848F)}.selectContainer.svelte-e3bo9s input.svelte-e3bo9s:focus{outline:none}.selectContainer.svelte-e3bo9s:hover{border-color:var(--borderHoverColor, #b2b8bf)}.selectContainer.focused.svelte-e3bo9s{border-color:var(--borderFocusColor, #006FE8)}.selectContainer.disabled.svelte-e3bo9s{background:var(--disabledBackground, #EBEDEF);border-color:var(--disabledBorderColor, #EBEDEF);color:var(--disabledColor, #C1C6CC)}.selectContainer.disabled.svelte-e3bo9s input.svelte-e3bo9s::placeholder{color:var(--disabledPlaceholderColor, #C1C6CC)}.selectedItem.svelte-e3bo9s{line-height:var(--height, 42px);height:var(--height, 42px);overflow-x:hidden;padding:var(--selectedItemPadding, 0 20px 0 0)}.selectedItem.svelte-e3bo9s:focus{outline:none}.clearSelect.svelte-e3bo9s{position:absolute;right:var(--clearSelectRight, 10px);top:var(--clearSelectTop, 11px);bottom:var(--clearSelectBottom, 11px);width:var(--clearSelectWidth, 20px);color:var(--clearSelectColor, #c5cacf);flex:none !important}.clearSelect.svelte-e3bo9s:hover{color:var(--clearSelectHoverColor, #2c3e50)}.selectContainer.focused.svelte-e3bo9s .clearSelect.svelte-e3bo9s{color:var(--clearSelectFocusColor, #3F4F5F)\n  }.indicator.svelte-e3bo9s{position:absolute;right:var(--indicatorRight, 10px);top:var(--indicatorTop, 11px);width:var(--indicatorWidth, 20px);height:var(--indicatorHeight, 20px);color:var(--indicatorColor, #c5cacf)}.indicator.svelte-e3bo9s svg.svelte-e3bo9s{display:inline-block;fill:var(--indicatorFill, currentcolor);line-height:1;stroke:var(--indicatorStroke, currentcolor);stroke-width:0}.spinner.svelte-e3bo9s{position:absolute;right:var(--spinnerRight, 10px);top:var(--spinnerLeft, 11px);width:var(--spinnerWidth, 20px);height:var(--spinnerHeight, 20px);color:var(--spinnerColor, #51ce6c);animation:svelte-e3bo9s-rotate 0.75s linear infinite}.spinner_icon.svelte-e3bo9s{display:block;height:100%;transform-origin:center center;width:100%;position:absolute;top:0;bottom:0;left:0;right:0;margin:auto;-webkit-transform:none}.spinner_path.svelte-e3bo9s{stroke-dasharray:90;stroke-linecap:round}.multiSelect.svelte-e3bo9s{display:flex;padding:var(--multiSelectPadding, 0 35px 0 16px);height:auto;flex-wrap:wrap}.multiSelect.svelte-e3bo9s>.svelte-e3bo9s{flex:1 1 50px}.selectContainer.multiSelect.svelte-e3bo9s input.svelte-e3bo9s{padding:var(--multiSelectInputPadding, 0);position:relative;margin:var(--multiSelectInputMargin, 0)}.hasError.svelte-e3bo9s{border:var(--errorBorder, 1px solid #FF2D55)}@keyframes svelte-e3bo9s-rotate{100%{transform:rotate(360deg)}}",
	map: "{\"version\":3,\"file\":\"Select.svelte\",\"sources\":[\"Select.svelte\"],\"sourcesContent\":[\"<script>\\n  import { beforeUpdate, createEventDispatcher, onDestroy, onMount, tick } from 'svelte';\\n  import List from './List.svelte';\\n  import ItemComponent from './Item.svelte';\\n  import SelectionComponent from './Selection.svelte';\\n  import MultiSelectionComponent from './MultiSelection.svelte';\\n  import isOutOfViewport from './utils/isOutOfViewport';\\n  import debounce from './utils/debounce';\\n\\n  const dispatch = createEventDispatcher();\\n  export let container = undefined;\\n  export let input = undefined;\\n  export let Item = ItemComponent;\\n  export let Selection = SelectionComponent;\\n  export let MultiSelection = MultiSelectionComponent;\\n  export let isMulti = false;\\n  export let isDisabled = false;\\n  export let isCreatable = false;\\n  export let isFocused = false;\\n  export let selectedValue = undefined;\\n  export let filterText = '';\\n  export let placeholder = 'Select...';\\n  export let items = [];\\n  export let groupBy = undefined;\\n  export let groupFilter = (groups) => groups;\\n  export let isGroupHeaderSelectable = false;\\n  export let getGroupHeaderLabel = (option) => {\\n    return option.label\\n  };\\n  export let getOptionLabel = (option, filterText) => {\\n    return option.isCreator ? `Create \\\\\\\"${filterText}\\\\\\\"` : option.label;\\n  };\\n  export let optionIdentifier = 'value';\\n  export let loadOptions = undefined;\\n  export let hasError = false;\\n  export let containerStyles = '';\\n  export let getSelectionLabel = (option) => {\\n    if (option) return option.label\\n  };\\n\\n  export let createGroupHeaderItem = (groupValue) => {\\n    return {\\n      value: groupValue,\\n      label: groupValue\\n    }\\n  };\\n\\n  export let createItem = (filterText) => {\\n    return {\\n      value: filterText,\\n      label: filterText\\n    };\\n  };\\n\\n  export let isSearchable = true;\\n  export let inputStyles = '';\\n  export let isClearable = true;\\n  export let isWaiting = false;\\n  export let listPlacement = 'auto';\\n  export let listOpen = false;\\n  export let list = undefined;\\n  export let isVirtualList = false;\\n  export let loadOptionsInterval = 300;\\n  export let noOptionsMessage = 'No options';\\n  export let hideEmptyState = false;\\n  export let filteredItems = [];\\n  export let inputAttributes = {};\\n  export let listAutoWidth = true;\\n  \\n\\n  let target;\\n  let activeSelectedValue;\\n  let _items = [];\\n  let originalItemsClone;\\n  let containerClasses = '';\\n  let prev_selectedValue;\\n  let prev_listOpen;\\n  let prev_filterText;\\n  let prev_isFocused;\\n  let prev_filteredItems;\\n\\n  async function resetFilter() {\\n    await tick();\\n    filterText = '';\\n  }\\n\\n  const getItems = debounce(async () => {\\n    isWaiting = true;\\n    \\n    items = await loadOptions(filterText);\\n  \\n    isWaiting = false;\\n    isFocused = true;\\n    listOpen = true;\\n  }, loadOptionsInterval);\\n\\n  $: {\\n    containerClasses = `selectContainer`;\\n    containerClasses += isMulti ? ' multiSelect' : '';\\n    containerClasses += isDisabled ? ' disabled' : '';\\n    containerClasses += isFocused ? ' focused' : '';\\n  }\\n\\n  $: {\\n    if (typeof selectedValue === 'string') {\\n      selectedValue = { [optionIdentifier]: selectedValue, label: selectedValue }\\n    }\\n  }\\n\\n  $: showSelectedItem = selectedValue && filterText.length === 0;\\n\\n  $: placeholderText = selectedValue ? '' : placeholder;\\n\\n  let _inputAttributes = {};\\n  $: {\\n    _inputAttributes = Object.assign(inputAttributes, {\\n      autocomplete: 'off',\\n      autocorrect: 'off',\\n      spellcheck: false\\n    })\\n\\n    if (!isSearchable) {\\n      _inputAttributes.readonly = true;\\n    }\\n  }\\n\\n  $: {\\n    let _filteredItems;\\n    let _items = items;\\n\\n    if (items && items.length > 0 && typeof items[0] !== 'object') {\\n      _items = items.map((item, index) => {\\n        return {\\n          index,\\n          value: item,\\n          label: item\\n        }\\n      })\\n    }\\n\\n    if (loadOptions && filterText.length === 0 && originalItemsClone) {\\n      _filteredItems = JSON.parse(originalItemsClone);\\n      _items = JSON.parse(originalItemsClone);\\n    } else {\\n      _filteredItems = loadOptions ? filterText.length === 0 ? [] : _items : _items.filter(item => {\\n\\n        let keepItem = true;\\n\\n        if (isMulti && selectedValue) {\\n          keepItem = !selectedValue.find((value) => {\\n            return value[optionIdentifier] === item[optionIdentifier]\\n          });\\n        }\\n\\n        if (keepItem && filterText.length < 1) return true;\\n\\n        return keepItem && getOptionLabel(item, filterText).toLowerCase().includes(filterText.toLowerCase());\\n      });\\n    }\\n\\n    if (groupBy) {\\n      const groupValues = [];\\n      const groups = {};\\n\\n      _filteredItems.forEach((item) => {\\n        const groupValue = groupBy(item);\\n\\n        if (!groupValues.includes(groupValue)) {\\n          groupValues.push(groupValue);\\n          groups[groupValue] = [];\\n\\n          if(groupValue) {\\n            groups[groupValue].push(Object.assign(\\n              createGroupHeaderItem(groupValue, item), \\n              { \\n                id: groupValue, \\n                isGroupHeader: true, \\n                isSelectable: isGroupHeaderSelectable\\n              }\\n            ));\\n          }\\n        }\\n        \\n        groups[groupValue].push(Object.assign({ isGroupItem: !!groupValue }, item));\\n      });\\n\\n      const sortedGroupedItems = [];\\n\\n      groupFilter(groupValues).forEach((groupValue) => {\\n        sortedGroupedItems.push(...groups[groupValue]);\\n      });\\n\\n      filteredItems = sortedGroupedItems;\\n    } else {\\n      filteredItems = _filteredItems;\\n    }\\n  }\\n\\n  beforeUpdate(() => {\\n    if (isMulti && selectedValue && selectedValue.length > 1) {\\n      checkSelectedValueForDuplicates();\\n    }\\n\\n    if (!isMulti && selectedValue && prev_selectedValue !== selectedValue) {\\n      if (!prev_selectedValue || JSON.stringify(selectedValue[optionIdentifier]) !== JSON.stringify(prev_selectedValue[optionIdentifier])) {\\n        dispatch('select', selectedValue);\\n      }\\n    }\\n\\n    if (isMulti && JSON.stringify(selectedValue) !== JSON.stringify(prev_selectedValue)) {\\n      if (checkSelectedValueForDuplicates()) {\\n        dispatch('select', selectedValue);\\n      }\\n    }\\n\\n    if (container && listOpen !== prev_listOpen) {\\n      if (listOpen) {\\n        loadList();\\n      } else {\\n        removeList();\\n      }\\n    }\\n\\n    if (filterText !== prev_filterText) {\\n      if (filterText.length > 0) {\\n        isFocused = true;\\n        listOpen = true;\\n\\n        if (loadOptions) {\\n          getItems();\\n        } else {\\n          loadList();\\n          listOpen = true;\\n\\n          if (isMulti) {\\n            activeSelectedValue = undefined\\n          }\\n        }\\n      } else {\\n        setList([])\\n      }\\n\\n      if (list) {\\n        list.$set({\\n          filterText\\n        });\\n      }\\n    }\\n\\n    if (isFocused !== prev_isFocused) {\\n      if (isFocused || listOpen) {\\n        handleFocus();\\n      } else {\\n        resetFilter();\\n        if (input) input.blur();\\n      }\\n    }\\n\\n    if (prev_filteredItems !== filteredItems) {\\n      let _filteredItems = [...filteredItems];\\n\\n      if (isCreatable && filterText) {\\n        const itemToCreate = {\\n          ...createItem(filterText),\\n          isCreator: true\\n        };\\n\\n        const existingItemWithFilterValue = _filteredItems.find((item) => {\\n          return item[optionIdentifier] === itemToCreate[optionIdentifier];\\n        });\\n\\n        let existingSelectionWithFilterValue;\\n\\n        if (selectedValue) {\\n          if (isMulti) {\\n            existingSelectionWithFilterValue = selectedValue.find((selection) => {\\n              return selection[optionIdentifier] === itemToCreate[optionIdentifier];\\n            });\\n          } else if (selectedValue[optionIdentifier] === itemToCreate[optionIdentifier]) {\\n            existingSelectionWithFilterValue = selectedValue;\\n          }\\n        }\\n\\n        if (!existingItemWithFilterValue && !existingSelectionWithFilterValue) {\\n          _filteredItems = [..._filteredItems, itemToCreate];\\n        }\\n      }\\n\\n      setList(_filteredItems);\\n    }\\n\\n    prev_selectedValue = selectedValue;\\n    prev_listOpen = listOpen;\\n    prev_filterText = filterText;\\n    prev_isFocused = isFocused;\\n    prev_filteredItems = filteredItems;\\n  });\\n\\n  function checkSelectedValueForDuplicates() {\\n    let noDuplicates = true;\\n    if (selectedValue) {\\n      const ids = [];\\n      const uniqueValues = [];\\n\\n      selectedValue.forEach(val => {\\n        if (!ids.includes(val[optionIdentifier])) {\\n          ids.push(val[optionIdentifier]);\\n          uniqueValues.push(val);\\n        } else {\\n          noDuplicates = false;\\n        }\\n      })\\n\\n      selectedValue = uniqueValues\\n    }\\n    return noDuplicates;\\n  }\\n\\n  async function setList(items) {\\n    await tick();\\n    if (list) return list.$set({ items })\\n    if (loadOptions && items.length > 0) loadList();\\n  }\\n\\n  function handleMultiItemClear(event) {\\n    const { detail } = event;\\n    const itemToRemove = selectedValue[detail ? detail.i : selectedValue.length - 1];\\n\\n    if (selectedValue.length === 1) {\\n      selectedValue = undefined;\\n    } else {\\n      selectedValue = selectedValue.filter((item) => {\\n        return item !== itemToRemove;\\n      });\\n    }\\n\\n    dispatch('clear', itemToRemove);\\n    \\n    getPosition();\\n  }\\n\\n  async function getPosition() {\\n    await tick();\\n    if (!target || !container) return;\\n    const { top, height, width } = container.getBoundingClientRect();\\n\\n    target.style['min-width'] = `${width}px`;\\n    target.style.width = `${listAutoWidth ? 'auto' : '100%'}`;\\n    target.style.left = '0';\\n\\n    if (listPlacement === 'top') {\\n      target.style.bottom = `${height + 5}px`;\\n    } else {\\n      target.style.top = `${height + 5}px`;\\n    }\\n\\n    target = target;\\n\\n    if (listPlacement === 'auto' && isOutOfViewport(target).bottom) {\\n      target.style.top = ``;\\n      target.style.bottom = `${height + 5}px`;\\n    }\\n\\n    target.style.visibility = '';\\n  }\\n\\n  function handleKeyDown(e) {\\n    if (!isFocused) return;\\n\\n    switch (e.key) {\\n      case 'ArrowDown':\\n        e.preventDefault();\\n        listOpen = true;\\n        activeSelectedValue = undefined;\\n        break;\\n      case 'ArrowUp':\\n        e.preventDefault();\\n        listOpen = true;\\n        activeSelectedValue = undefined;\\n        break;\\n      case 'Tab':\\n        if (!listOpen) isFocused = false;\\n        break;\\n      case 'Backspace':\\n        if (!isMulti || filterText.length > 0) return;\\n        if (isMulti && selectedValue && selectedValue.length > 0) {\\n          handleMultiItemClear(activeSelectedValue !== undefined ? activeSelectedValue : selectedValue.length - 1);\\n          if (activeSelectedValue === 0 || activeSelectedValue === undefined) break;\\n          activeSelectedValue = selectedValue.length > activeSelectedValue ? activeSelectedValue - 1 : undefined;\\n        }\\n        break;\\n      case 'ArrowLeft':\\n        if (list) list.$set({ hoverItemIndex: -1 });\\n        if (!isMulti || filterText.length > 0) return;\\n\\n        if (activeSelectedValue === undefined) {\\n          activeSelectedValue = selectedValue.length - 1;\\n        } else if (selectedValue.length > activeSelectedValue && activeSelectedValue !== 0) {\\n          activeSelectedValue -= 1\\n        }\\n        break;\\n      case 'ArrowRight':\\n        if (list) list.$set({ hoverItemIndex: -1 });\\n        if (!isMulti || filterText.length > 0 || activeSelectedValue === undefined) return;\\n        if (activeSelectedValue === selectedValue.length - 1) {\\n          activeSelectedValue = undefined;\\n        } else if (activeSelectedValue < selectedValue.length - 1) {\\n          activeSelectedValue += 1;\\n        }\\n        break;\\n    }\\n  }\\n\\n  function handleFocus() {\\n    isFocused = true;\\n    if (input) input.focus();\\n  }\\n\\n  function removeList() {\\n    resetFilter();\\n    activeSelectedValue = undefined;\\n\\n    if (!list) return;\\n    list.$destroy();\\n    list = undefined;\\n\\n    if (!target) return;\\n    if (target.parentNode) target.parentNode.removeChild(target);\\n    target = undefined;\\n\\n    list = list;\\n    target = target;\\n  }\\n\\n  function handleWindowClick(event) {\\n    if (!container) return;\\n    if (container.contains(event.target)) return;\\n    isFocused = false;\\n    listOpen = false;\\n    activeSelectedValue = undefined;\\n    if (input) input.blur();\\n  }\\n\\n  function handleClick() {\\n    if (isDisabled) return;\\n    isFocused = true;\\n    listOpen = !listOpen;\\n  }\\n\\n  export function handleClear() {\\n    selectedValue = undefined;\\n    listOpen = false;\\n    dispatch('clear', selectedValue);\\n    handleFocus();\\n  }\\n\\n  async function loadList() {\\n    await tick();\\n    if (target && list) return;\\n\\n    const data = {\\n      Item,\\n      filterText,\\n      optionIdentifier,\\n      noOptionsMessage,\\n      hideEmptyState,\\n      isVirtualList,\\n      selectedValue,\\n      isMulti,\\n      getGroupHeaderLabel,\\n      items: filteredItems\\n    };\\n\\n    if (getOptionLabel) {\\n      data.getOptionLabel = getOptionLabel;\\n    }\\n\\n    target = document.createElement('div');\\n\\n    Object.assign(target.style, {\\n      position: 'absolute',\\n      'z-index': 2,\\n      'visibility': 'hidden'\\n    });\\n\\n    list = list;\\n    target = target;\\n    if (container) container.appendChild(target);\\n\\n    list = new List({\\n      target,\\n      props: data\\n    });\\n\\n    list.$on('itemSelected', (event) => {\\n      const { detail } = event;\\n\\n      if (detail) {\\n        const item = Object.assign({}, detail);\\n\\n        if (isMulti) {\\n          selectedValue = selectedValue ? selectedValue.concat([item]) : [item];\\n        } else {\\n          selectedValue = item;\\n        }\\n\\n        resetFilter();\\n        selectedValue = selectedValue;\\n\\n        setTimeout(() => {\\n          listOpen = false;\\n          activeSelectedValue = undefined;\\n        });\\n      }\\n    });\\n\\n    list.$on('itemCreated', (event) => {\\n      const { detail } = event;\\n      if (isMulti) {\\n        selectedValue = selectedValue || [];\\n        selectedValue = [...selectedValue, createItem(detail)]\\n      } else {\\n        selectedValue = createItem(detail)\\n      }\\n\\n      filterText = '';\\n      listOpen = false;\\n      activeSelectedValue = undefined;\\n      resetFilter();\\n    });\\n    \\n    list.$on('closeList', () => {\\n      listOpen = false;\\n    });\\n  \\n    list = list,\\n    target = target;\\n    getPosition();\\n  }\\n\\n  onMount(() => {\\n    if (isFocused) input.focus();\\n    if (listOpen) loadList();\\n\\n    if (items && items.length > 0) {\\n      originalItemsClone = JSON.stringify(items);\\n    }\\n\\n    if (selectedValue) {\\n      if (isMulti) {\\n        selectedValue = selectedValue.map(item => {\\n          if (typeof item === 'string') {\\n            return { value: item, label: item }\\n          } else {\\n            return item;\\n          }\\n        })\\n      }\\n    }\\n  });\\n\\n  onDestroy(() => {\\n    removeList()\\n  });\\n</script>\\n\\n<svelte:window on:click=\\\"{handleWindowClick}\\\" on:keydown=\\\"{handleKeyDown}\\\" on:resize=\\\"{getPosition}\\\" />\\n\\n<div class=\\\"{containerClasses} {hasError ? 'hasError' : ''}\\\" style=\\\"{containerStyles}\\\" on:click=\\\"{handleClick}\\\"\\n  bind:this={container}>\\n\\n  {#if isMulti && selectedValue && selectedValue.length > 0}\\n  <svelte:component\\n    this=\\\"{MultiSelection}\\\"\\n    {selectedValue}\\n    {getSelectionLabel}\\n    {activeSelectedValue}\\n    {isDisabled}\\n    on:multiItemClear=\\\"{handleMultiItemClear}\\\"\\n    on:focus=\\\"{handleFocus}\\\"\\n  />\\n  {/if}\\n\\n  <input\\n    {..._inputAttributes}\\n    bind:this={input}\\n    on:focus=\\\"{handleFocus}\\\"\\n    bind:value=\\\"{filterText}\\\"    \\n    placeholder=\\\"{placeholderText}\\\"\\n    disabled=\\\"{isDisabled}\\\"\\n    style=\\\"{inputStyles}\\\"\\n  >\\n\\n  {#if !isMulti && showSelectedItem }\\n  <div class=\\\"selectedItem\\\" on:focus=\\\"{handleFocus}\\\">\\n    <svelte:component this=\\\"{Selection}\\\" item={selectedValue} {getSelectionLabel}/>\\n  </div>\\n  {/if}\\n\\n  {#if showSelectedItem && isClearable && !isDisabled && !isWaiting}\\n  <div class=\\\"clearSelect\\\" on:click|preventDefault=\\\"{handleClear}\\\">\\n    <svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"-2 -2 50 50\\\" focusable=\\\"false\\\"\\n         role=\\\"presentation\\\">\\n      <path fill=\\\"currentColor\\\"\\n            d=\\\"M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z\\\"></path>\\n    </svg>\\n  </div>\\n  {/if}\\n\\n  {#if !isSearchable && !isDisabled && !isWaiting && (showSelectedItem && !isClearable || !showSelectedItem)}\\n  <div class=\\\"indicator\\\">\\n    <svg width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 20 20\\\" focusable=\\\"false\\\" class=\\\"css-19bqh2r\\\">\\n      <path\\n        d=\\\"M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z\\\"></path>\\n    </svg>\\n  </div>\\n  {/if}\\n\\n  {#if isWaiting}\\n  <div class=\\\"spinner\\\">\\n    <svg class=\\\"spinner_icon\\\" viewBox=\\\"25 25 50 50\\\">\\n      <circle class=\\\"spinner_path\\\" cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"20\\\" fill=\\\"none\\\" stroke=\\\"currentColor\\\" stroke-width=\\\"5\\\"\\n              stroke-miterlimit=\\\"10\\\"></circle>\\n    </svg>\\n  </div>\\n  {/if}\\n</div>\\n\\n<style>\\n  .selectContainer {\\n    border: var(--border, 1px solid #D8DBDF);\\n    border-radius: var(--borderRadius, 3px);\\n    height: var(--height, 42px);\\n    position: relative;\\n    display: flex;\\n    padding: var(--padding, 0 16px);\\n    background: var(--background, #fff);\\n  }\\n\\n  .selectContainer input {\\n    cursor: default;\\n    border: none;\\n    color: var(--inputColor, #3F4F5F);\\n    height: var(--height, 42px);\\n    line-height: var(--height, 42px);\\n    padding: var(--padding, 0 16px);\\n    width: 100%;\\n    background: transparent;\\n    font-size: var(--inputFontSize, 14px);\\n    letter-spacing: var(--inputLetterSpacing, -0.08px);\\n    position: absolute;\\n    left: 0;\\n  }\\n\\n  .selectContainer input::placeholder {\\n    color: var(--placeholderColor, #78848F);\\n  }\\n\\n  .selectContainer input:focus {\\n    outline: none;\\n  }\\n\\n  .selectContainer:hover {\\n    border-color: var(--borderHoverColor, #b2b8bf);\\n  }\\n\\n  .selectContainer.focused {\\n    border-color: var(--borderFocusColor, #006FE8);\\n  }\\n\\n  .selectContainer.disabled {\\n    background: var(--disabledBackground, #EBEDEF);\\n    border-color: var(--disabledBorderColor, #EBEDEF);\\n    color: var(--disabledColor, #C1C6CC);\\n  }\\n\\n  .selectContainer.disabled input::placeholder {\\n    color: var(--disabledPlaceholderColor, #C1C6CC);\\n  }\\n\\n  .selectedItem {\\n    line-height: var(--height, 42px);\\n    height: var(--height, 42px);\\n    overflow-x: hidden;\\n    padding: var(--selectedItemPadding, 0 20px 0 0);\\n  }\\n\\n  .selectedItem:focus {\\n    outline: none;\\n  }\\n\\n  .clearSelect {\\n    position: absolute;\\n    right: var(--clearSelectRight, 10px);\\n    top: var(--clearSelectTop, 11px);\\n    bottom: var(--clearSelectBottom, 11px);\\n    width: var(--clearSelectWidth, 20px);\\n    color: var(--clearSelectColor, #c5cacf);\\n    flex: none !important;\\n  }\\n\\n  .clearSelect:hover {\\n    color: var(--clearSelectHoverColor, #2c3e50);\\n  }\\n\\n  .selectContainer.focused .clearSelect {\\n    color: var(--clearSelectFocusColor, #3F4F5F)\\n  }\\n\\n  .indicator {\\n    position: absolute;\\n    right: var(--indicatorRight, 10px);\\n    top: var(--indicatorTop, 11px);\\n    width: var(--indicatorWidth, 20px);\\n    height: var(--indicatorHeight, 20px);\\n    color: var(--indicatorColor, #c5cacf);\\n  }\\n\\n  .indicator svg {\\n    display: inline-block;\\n    fill: var(--indicatorFill, currentcolor);\\n    line-height: 1;\\n    stroke: var(--indicatorStroke, currentcolor);\\n    stroke-width: 0;\\n  }\\n\\n  .spinner {\\n    position: absolute;\\n    right: var(--spinnerRight, 10px);\\n    top: var(--spinnerLeft, 11px);\\n    width: var(--spinnerWidth, 20px);\\n    height: var(--spinnerHeight, 20px);\\n    color: var(--spinnerColor, #51ce6c);\\n    animation: rotate 0.75s linear infinite;\\n  }\\n\\n  .spinner_icon {\\n    display: block;\\n    height: 100%;\\n    transform-origin: center center;\\n    width: 100%;\\n    position: absolute;\\n    top: 0;\\n    bottom: 0;\\n    left: 0;\\n    right: 0;\\n    margin: auto;\\n    -webkit-transform: none;\\n  }\\n\\n  .spinner_path {\\n    stroke-dasharray: 90;\\n    stroke-linecap: round;\\n  }\\n\\n  .multiSelect {\\n    display: flex;\\n    padding: var(--multiSelectPadding, 0 35px 0 16px);\\n    height: auto;\\n    flex-wrap: wrap;\\n  }\\n\\n  .multiSelect > * {\\n    flex: 1 1 50px;\\n  }\\n\\n  .selectContainer.multiSelect input {\\n    padding: var(--multiSelectInputPadding, 0);\\n    position: relative;\\n    margin: var(--multiSelectInputMargin, 0);\\n  }\\n\\n  .hasError {\\n    border: var(--errorBorder, 1px solid #FF2D55);\\n  }\\n\\n  @keyframes rotate {\\n    100% {\\n      transform: rotate(360deg);\\n    }\\n  }\\n</style>\\n\"],\"names\":[],\"mappings\":\"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\"}"
};

const Select = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	const dispatch = index.createEventDispatcher();
	let { container = undefined } = $$props;
	let { input = undefined } = $$props;
	let { Item: Item$1 = Item } = $$props;
	let { Selection: Selection$1 = Selection } = $$props;
	let { MultiSelection: MultiSelection$1 = MultiSelection } = $$props;
	let { isMulti = false } = $$props;
	let { isDisabled = false } = $$props;
	let { isCreatable = false } = $$props;
	let { isFocused = false } = $$props;
	let { selectedValue = undefined } = $$props;
	let { filterText = "" } = $$props;
	let { placeholder = "Select..." } = $$props;
	let { items = [] } = $$props;
	let { groupBy = undefined } = $$props;
	let { groupFilter = groups => groups } = $$props;
	let { isGroupHeaderSelectable = false } = $$props;

	let { getGroupHeaderLabel = option => {
		return option.label;
	} } = $$props;

	let { getOptionLabel = (option, filterText) => {
		return option.isCreator
		? `Create \"${filterText}\"`
		: option.label;
	} } = $$props;

	let { optionIdentifier = "value" } = $$props;
	let { loadOptions = undefined } = $$props;
	let { hasError = false } = $$props;
	let { containerStyles = "" } = $$props;

	let { getSelectionLabel = option => {
		if (option) return option.label;
	} } = $$props;

	let { createGroupHeaderItem = groupValue => {
		return { value: groupValue, label: groupValue };
	} } = $$props;

	let { createItem = filterText => {
		return { value: filterText, label: filterText };
	} } = $$props;

	let { isSearchable = true } = $$props;
	let { inputStyles = "" } = $$props;
	let { isClearable = true } = $$props;
	let { isWaiting = false } = $$props;
	let { listPlacement = "auto" } = $$props;
	let { listOpen = false } = $$props;
	let { list = undefined } = $$props;
	let { isVirtualList = false } = $$props;
	let { loadOptionsInterval = 300 } = $$props;
	let { noOptionsMessage = "No options" } = $$props;
	let { hideEmptyState = false } = $$props;
	let { filteredItems = [] } = $$props;
	let { inputAttributes = {} } = $$props;
	let { listAutoWidth = true } = $$props;
	let target;
	let activeSelectedValue;
	let originalItemsClone;
	let containerClasses = "";
	let prev_selectedValue;
	let prev_listOpen;
	let prev_filterText;
	let prev_isFocused;
	let prev_filteredItems;

	async function resetFilter() {
		await index.tick();
		filterText = "";
	}

	const getItems = debounce(
		async () => {
			isWaiting = true;
			items = await loadOptions(filterText);
			isWaiting = false;
			isFocused = true;
			listOpen = true;
		},
		loadOptionsInterval
	);

	let _inputAttributes = {};

	index.beforeUpdate(() => {
		if (isMulti && selectedValue && selectedValue.length > 1) {
			checkSelectedValueForDuplicates();
		}

		if (!isMulti && selectedValue && prev_selectedValue !== selectedValue) {
			if (!prev_selectedValue || JSON.stringify(selectedValue[optionIdentifier]) !== JSON.stringify(prev_selectedValue[optionIdentifier])) {
				dispatch("select", selectedValue);
			}
		}

		if (isMulti && JSON.stringify(selectedValue) !== JSON.stringify(prev_selectedValue)) {
			if (checkSelectedValueForDuplicates()) {
				dispatch("select", selectedValue);
			}
		}

		if (container && listOpen !== prev_listOpen) {
			if (listOpen) {
				loadList();
			} else {
				removeList();
			}
		}

		if (filterText !== prev_filterText) {
			if (filterText.length > 0) {
				isFocused = true;
				listOpen = true;

				if (loadOptions) {
					getItems();
				} else {
					loadList();
					listOpen = true;

					if (isMulti) {
						activeSelectedValue = undefined;
					}
				}
			} else {
				setList([]);
			}

			if (list) {
				list.$set({ filterText });
			}
		}

		if (isFocused !== prev_isFocused) {
			if (isFocused || listOpen) {
				handleFocus();
			} else {
				resetFilter();
				if (input) input.blur();
			}
		}

		if (prev_filteredItems !== filteredItems) {
			let _filteredItems = [...filteredItems];

			if (isCreatable && filterText) {
				const itemToCreate = {
					...createItem(filterText),
					isCreator: true
				};

				const existingItemWithFilterValue = _filteredItems.find(item => {
					return item[optionIdentifier] === itemToCreate[optionIdentifier];
				});

				let existingSelectionWithFilterValue;

				if (selectedValue) {
					if (isMulti) {
						existingSelectionWithFilterValue = selectedValue.find(selection => {
							return selection[optionIdentifier] === itemToCreate[optionIdentifier];
						});
					} else if (selectedValue[optionIdentifier] === itemToCreate[optionIdentifier]) {
						existingSelectionWithFilterValue = selectedValue;
					}
				}

				if (!existingItemWithFilterValue && !existingSelectionWithFilterValue) {
					_filteredItems = [..._filteredItems, itemToCreate];
				}
			}

			setList(_filteredItems);
		}

		prev_selectedValue = selectedValue;
		prev_listOpen = listOpen;
		prev_filterText = filterText;
		prev_isFocused = isFocused;
		prev_filteredItems = filteredItems;
	});

	function checkSelectedValueForDuplicates() {
		let noDuplicates = true;

		if (selectedValue) {
			const ids = [];
			const uniqueValues = [];

			selectedValue.forEach(val => {
				if (!ids.includes(val[optionIdentifier])) {
					ids.push(val[optionIdentifier]);
					uniqueValues.push(val);
				} else {
					noDuplicates = false;
				}
			});

			selectedValue = uniqueValues;
		}

		return noDuplicates;
	}

	async function setList(items) {
		await index.tick();
		if (list) return list.$set({ items });
		if (loadOptions && items.length > 0) loadList();
	}

	async function getPosition() {
		await index.tick();
		if (!target || !container) return;
		const { top, height, width } = container.getBoundingClientRect();
		target.style["min-width"] = `${width}px`;
		target.style.width = `${listAutoWidth ? "auto" : "100%"}`;
		target.style.left = "0";

		if (listPlacement === "top") {
			target.style.bottom = `${height + 5}px`;
		} else {
			target.style.top = `${height + 5}px`;
		}

		target = target;

		if (listPlacement === "auto" && isOutOfViewport(target).bottom) {
			target.style.top = ``;
			target.style.bottom = `${height + 5}px`;
		}

		target.style.visibility = "";
	}

	function handleFocus() {
		isFocused = true;
		if (input) input.focus();
	}

	function removeList() {
		resetFilter();
		activeSelectedValue = undefined;
		if (!list) return;
		list.$destroy();
		list = undefined;
		if (!target) return;
		if (target.parentNode) target.parentNode.removeChild(target);
		target = undefined;
		list = list;
		target = target;
	}

	function handleClear() {
		selectedValue = undefined;
		listOpen = false;
		dispatch("clear", selectedValue);
		handleFocus();
	}

	async function loadList() {
		await index.tick();
		if (target && list) return;

		const data = {
			Item: Item$1,
			filterText,
			optionIdentifier,
			noOptionsMessage,
			hideEmptyState,
			isVirtualList,
			selectedValue,
			isMulti,
			getGroupHeaderLabel,
			items: filteredItems
		};

		if (getOptionLabel) {
			data.getOptionLabel = getOptionLabel;
		}

		target = document.createElement("div");

		Object.assign(target.style, {
			position: "absolute",
			"z-index": 2,
			"visibility": "hidden"
		});

		list = list;
		target = target;
		if (container) container.appendChild(target);
		list = new List({ target, props: data });

		list.$on("itemSelected", event => {
			const { detail } = event;

			if (detail) {
				const item = Object.assign({}, detail);

				if (isMulti) {
					selectedValue = selectedValue ? selectedValue.concat([item]) : [item];
				} else {
					selectedValue = item;
				}

				resetFilter();
				selectedValue = selectedValue;

				setTimeout(() => {
					listOpen = false;
					activeSelectedValue = undefined;
				});
			}
		});

		list.$on("itemCreated", event => {
			const { detail } = event;

			if (isMulti) {
				selectedValue = selectedValue || [];
				selectedValue = [...selectedValue, createItem(detail)];
			} else {
				selectedValue = createItem(detail);
			}

			filterText = "";
			listOpen = false;
			activeSelectedValue = undefined;
			resetFilter();
		});

		list.$on("closeList", () => {
			listOpen = false;
		});

		(list = list, target = target);
		getPosition();
	}

	index.onMount(() => {
		if (isFocused) input.focus();
		if (listOpen) loadList();

		if (items && items.length > 0) {
			originalItemsClone = JSON.stringify(items);
		}

		if (selectedValue) {
			if (isMulti) {
				selectedValue = selectedValue.map(item => {
					if (typeof item === "string") {
						return { value: item, label: item };
					} else {
						return item;
					}
				});
			}
		}
	});

	index.onDestroy(() => {
		removeList();
	});

	if ($$props.container === void 0 && $$bindings.container && container !== void 0) $$bindings.container(container);
	if ($$props.input === void 0 && $$bindings.input && input !== void 0) $$bindings.input(input);
	if ($$props.Item === void 0 && $$bindings.Item && Item$1 !== void 0) $$bindings.Item(Item$1);
	if ($$props.Selection === void 0 && $$bindings.Selection && Selection$1 !== void 0) $$bindings.Selection(Selection$1);
	if ($$props.MultiSelection === void 0 && $$bindings.MultiSelection && MultiSelection$1 !== void 0) $$bindings.MultiSelection(MultiSelection$1);
	if ($$props.isMulti === void 0 && $$bindings.isMulti && isMulti !== void 0) $$bindings.isMulti(isMulti);
	if ($$props.isDisabled === void 0 && $$bindings.isDisabled && isDisabled !== void 0) $$bindings.isDisabled(isDisabled);
	if ($$props.isCreatable === void 0 && $$bindings.isCreatable && isCreatable !== void 0) $$bindings.isCreatable(isCreatable);
	if ($$props.isFocused === void 0 && $$bindings.isFocused && isFocused !== void 0) $$bindings.isFocused(isFocused);
	if ($$props.selectedValue === void 0 && $$bindings.selectedValue && selectedValue !== void 0) $$bindings.selectedValue(selectedValue);
	if ($$props.filterText === void 0 && $$bindings.filterText && filterText !== void 0) $$bindings.filterText(filterText);
	if ($$props.placeholder === void 0 && $$bindings.placeholder && placeholder !== void 0) $$bindings.placeholder(placeholder);
	if ($$props.items === void 0 && $$bindings.items && items !== void 0) $$bindings.items(items);
	if ($$props.groupBy === void 0 && $$bindings.groupBy && groupBy !== void 0) $$bindings.groupBy(groupBy);
	if ($$props.groupFilter === void 0 && $$bindings.groupFilter && groupFilter !== void 0) $$bindings.groupFilter(groupFilter);
	if ($$props.isGroupHeaderSelectable === void 0 && $$bindings.isGroupHeaderSelectable && isGroupHeaderSelectable !== void 0) $$bindings.isGroupHeaderSelectable(isGroupHeaderSelectable);
	if ($$props.getGroupHeaderLabel === void 0 && $$bindings.getGroupHeaderLabel && getGroupHeaderLabel !== void 0) $$bindings.getGroupHeaderLabel(getGroupHeaderLabel);
	if ($$props.getOptionLabel === void 0 && $$bindings.getOptionLabel && getOptionLabel !== void 0) $$bindings.getOptionLabel(getOptionLabel);
	if ($$props.optionIdentifier === void 0 && $$bindings.optionIdentifier && optionIdentifier !== void 0) $$bindings.optionIdentifier(optionIdentifier);
	if ($$props.loadOptions === void 0 && $$bindings.loadOptions && loadOptions !== void 0) $$bindings.loadOptions(loadOptions);
	if ($$props.hasError === void 0 && $$bindings.hasError && hasError !== void 0) $$bindings.hasError(hasError);
	if ($$props.containerStyles === void 0 && $$bindings.containerStyles && containerStyles !== void 0) $$bindings.containerStyles(containerStyles);
	if ($$props.getSelectionLabel === void 0 && $$bindings.getSelectionLabel && getSelectionLabel !== void 0) $$bindings.getSelectionLabel(getSelectionLabel);
	if ($$props.createGroupHeaderItem === void 0 && $$bindings.createGroupHeaderItem && createGroupHeaderItem !== void 0) $$bindings.createGroupHeaderItem(createGroupHeaderItem);
	if ($$props.createItem === void 0 && $$bindings.createItem && createItem !== void 0) $$bindings.createItem(createItem);
	if ($$props.isSearchable === void 0 && $$bindings.isSearchable && isSearchable !== void 0) $$bindings.isSearchable(isSearchable);
	if ($$props.inputStyles === void 0 && $$bindings.inputStyles && inputStyles !== void 0) $$bindings.inputStyles(inputStyles);
	if ($$props.isClearable === void 0 && $$bindings.isClearable && isClearable !== void 0) $$bindings.isClearable(isClearable);
	if ($$props.isWaiting === void 0 && $$bindings.isWaiting && isWaiting !== void 0) $$bindings.isWaiting(isWaiting);
	if ($$props.listPlacement === void 0 && $$bindings.listPlacement && listPlacement !== void 0) $$bindings.listPlacement(listPlacement);
	if ($$props.listOpen === void 0 && $$bindings.listOpen && listOpen !== void 0) $$bindings.listOpen(listOpen);
	if ($$props.list === void 0 && $$bindings.list && list !== void 0) $$bindings.list(list);
	if ($$props.isVirtualList === void 0 && $$bindings.isVirtualList && isVirtualList !== void 0) $$bindings.isVirtualList(isVirtualList);
	if ($$props.loadOptionsInterval === void 0 && $$bindings.loadOptionsInterval && loadOptionsInterval !== void 0) $$bindings.loadOptionsInterval(loadOptionsInterval);
	if ($$props.noOptionsMessage === void 0 && $$bindings.noOptionsMessage && noOptionsMessage !== void 0) $$bindings.noOptionsMessage(noOptionsMessage);
	if ($$props.hideEmptyState === void 0 && $$bindings.hideEmptyState && hideEmptyState !== void 0) $$bindings.hideEmptyState(hideEmptyState);
	if ($$props.filteredItems === void 0 && $$bindings.filteredItems && filteredItems !== void 0) $$bindings.filteredItems(filteredItems);
	if ($$props.inputAttributes === void 0 && $$bindings.inputAttributes && inputAttributes !== void 0) $$bindings.inputAttributes(inputAttributes);
	if ($$props.listAutoWidth === void 0 && $$bindings.listAutoWidth && listAutoWidth !== void 0) $$bindings.listAutoWidth(listAutoWidth);
	if ($$props.handleClear === void 0 && $$bindings.handleClear && handleClear !== void 0) $$bindings.handleClear(handleClear);
	$$result.css.add(css$5);

	 {
		{
			containerClasses = `selectContainer`;
			containerClasses += isMulti ? " multiSelect" : "";
			containerClasses += isDisabled ? " disabled" : "";
			containerClasses += isFocused ? " focused" : "";
		}
	}

	 {
		{
			if (typeof selectedValue === "string") {
				selectedValue = {
					[optionIdentifier]: selectedValue,
					label: selectedValue
				};
			}
		}
	}

	let showSelectedItem = selectedValue && filterText.length === 0;
	let placeholderText = selectedValue ? "" : placeholder;

	 {
		{
			_inputAttributes = Object.assign(inputAttributes, {
				autocomplete: "off",
				autocorrect: "off",
				spellcheck: false
			});

			if (!isSearchable) {
				_inputAttributes.readonly = true;
			}
		}
	}

	 {
		{
			let _filteredItems;
			let _items = items;

			if (items && items.length > 0 && typeof items[0] !== "object") {
				_items = items.map((item, index) => {
					return { index, value: item, label: item };
				});
			}

			if (loadOptions && filterText.length === 0 && originalItemsClone) {
				_filteredItems = JSON.parse(originalItemsClone);
				_items = JSON.parse(originalItemsClone);
			} else {
				_filteredItems = loadOptions
				? filterText.length === 0 ? [] : _items
				: _items.filter(item => {
						let keepItem = true;

						if (isMulti && selectedValue) {
							keepItem = !selectedValue.find(value => {
								return value[optionIdentifier] === item[optionIdentifier];
							});
						}

						if (keepItem && filterText.length < 1) return true;
						return keepItem && getOptionLabel(item, filterText).toLowerCase().includes(filterText.toLowerCase());
					});
			}

			if (groupBy) {
				const groupValues = [];
				const groups = {};

				_filteredItems.forEach(item => {
					const groupValue = groupBy(item);

					if (!groupValues.includes(groupValue)) {
						groupValues.push(groupValue);
						groups[groupValue] = [];

						if (groupValue) {
							groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
								id: groupValue,
								isGroupHeader: true,
								isSelectable: isGroupHeaderSelectable
							}));
						}
					}

					groups[groupValue].push(Object.assign({ isGroupItem: !!groupValue }, item));
				});

				const sortedGroupedItems = [];

				groupFilter(groupValues).forEach(groupValue => {
					sortedGroupedItems.push(...groups[groupValue]);
				});

				filteredItems = sortedGroupedItems;
			} else {
				filteredItems = _filteredItems;
			}
		}
	}

	return `

<div class="${index.escape(containerClasses) + " " + index.escape(hasError ? "hasError" : "") + " svelte-e3bo9s"}"${index.add_attribute("style", containerStyles, 0)}${index.add_attribute("this", container, 1)}>

  ${isMulti && selectedValue && selectedValue.length > 0
	? `${index.validate_component(MultiSelection$1 || index.missing_component, "svelte:component").$$render(
			$$result,
			{
				selectedValue,
				getSelectionLabel,
				activeSelectedValue,
				isDisabled
			},
			{},
			{}
		)}`
	: ``}

  <input${index.spread(
		[
			_inputAttributes,
			{ placeholder: index.escape(placeholderText) },
			{ disabled: isDisabled || null },
			{ style: index.escape(inputStyles) }
		],
		"svelte-e3bo9s"
	)}${index.add_attribute("this", input, 1)}${index.add_attribute("value", filterText, 1)}>

  ${!isMulti && showSelectedItem
	? `<div class="${"selectedItem svelte-e3bo9s"}">
    ${index.validate_component(Selection$1 || index.missing_component, "svelte:component").$$render($$result, { item: selectedValue, getSelectionLabel }, {}, {})}
  </div>`
	: ``}

  ${showSelectedItem && isClearable && !isDisabled && !isWaiting
	? `<div class="${"clearSelect svelte-e3bo9s"}">
    <svg width="${"100%"}" height="${"100%"}" viewBox="${"-2 -2 50 50"}" focusable="${"false"}" role="${"presentation"}" class="${"svelte-e3bo9s"}">
      <path fill="${"currentColor"}" d="${"M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z"}"></path>
    </svg>
  </div>`
	: ``}

  ${!isSearchable && !isDisabled && !isWaiting && (showSelectedItem && !isClearable || !showSelectedItem)
	? `<div class="${"indicator svelte-e3bo9s"}">
    <svg width="${"100%"}" height="${"100%"}" viewBox="${"0 0 20 20"}" focusable="${"false"}" class="${"css-19bqh2r svelte-e3bo9s"}">
      <path d="${"M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"}"></path>
    </svg>
  </div>`
	: ``}

  ${isWaiting
	? `<div class="${"spinner svelte-e3bo9s"}">
    <svg class="${"spinner_icon svelte-e3bo9s"}" viewBox="${"25 25 50 50"}">
      <circle class="${"spinner_path svelte-e3bo9s"}" cx="${"50"}" cy="${"50"}" r="${"20"}" fill="${"none"}" stroke="${"currentColor"}" stroke-width="${"5"}" stroke-miterlimit="${"10"}"></circle>
    </svg>
  </div>`
	: ``}
</div>`;
});

exports.Select = Select;
